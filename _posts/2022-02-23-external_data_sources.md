---
layout: post
title: "External data sources: principles to remember"
categories: C++
keywords: programming; C++
---

You are working on a software project. Abstractly, it reads data from external one data source or more. It processes the data and outputs it. A very general abstraction that can match most professional software projects out there. Despite the ubiquity of such systems, I see some software developers forget or do not know some essential principles when working with such projects. 

Without loss of generality, your code looks something like this. 

```cpp
void run()
{
    for (auto& r: data_readers) 
    {
        auto data = r.read();
        auto p_data = process_data(data); 
        publish_data(p_data); 
    }
}
```

The format of the data received from the data sources `data_readers` is generally set by their owners. There is a _contract_ between the two systems. This contract inevitably changes from time to time. The data reader `read` function converts what it reads into a format acceptable or internal by our system.  Thus, the DataReader `read` function has two jobs: 1) read raw data from the external data source, 2) convert it to an acceptable format. 

```cpp
SystemMessage DataReader::read() 
{
    // ... some logic that depends on the external system. 
    // for example, read csv file or connect to a database etc .. 
    auto d = read_raw_data(); 
    return convert_data(d); 
}
```

Let's talk about `convert_data`. This process is sometimes called _data normalization_. This will change every time the format of the external data changes (that is, the _contract_ changes). As a developer:  

- **P1**. You should only change `convert_data` if the contract changes. 
- **P2**. You should design `convert_data` such that changing it takes the minimum amount of efforts.

Here are some examples: 

1. Your external data source is a csv file. The 4th field is for a unique identifier. Now, the identifier is in the 6th field. 
2. Your external data source is an accounting transaction file of JSON format. The amount field now is a combination of 2 fields instead of one. 




Let's talk about `read_raw_data`. The implemenation of this function depends on the external system. It may read from a database, socket, or files of different formats. As a developer: 

- **P3**. You should decouple the implementation details of external systems from your logic. In other words, use `dependency injection`. 

I will have to re-write my code above therefore. 

```cpp
SystemMessage DataReader::read() 
{
    auto d = _data_loader.read_raw_data(); 
    return _data_normalizer.normalize(d); 

    // Note: some systems set the type of d to be a generic data type generated by each data loader. 
    // In other cases, each data loader result is in a different data type. This does not change 
    // the main idea here that normalize (or what we called previously, convert_data) should be seperate 
    // and should be easy to modify. 
}
```


**How to test software systems that depends on continously changing external data sources?**

1. Get samples of the external data copied to a file.   
2. Write a mock data reader with a `_data_loader` that read your test file instead of the external data source. 
3. Start with an initial understanding of the data (that allows your system to work). 
- Test that the system works overall - even if the output of the data is not working (this can be seen as an integration test or testing your infrasture) 
4. Analyze test failures caused by either changing data format or wrong understanding of the data. 
5. Change `_data_normalizer.normalize` when needed. 
6. Repeat 4-5 as needed (this can be seen as business logic and data quality testing)

For step 4-5, isn't unit testing enough? It is necessary, but it is not enough. Quite often, the amount of data we deal and the frequency of their changes require that we create a different set of tests and tools other than unit tests. 



You probably won't be able to meet these objectives or principles because life is not perfect. You should at least try your best. In my opinion, if you miserably fail to meet these objectives, then there is a problem in your design. 